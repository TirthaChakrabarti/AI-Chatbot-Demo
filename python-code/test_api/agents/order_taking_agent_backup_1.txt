import boto3
import os
import json 
from .utils import get_chatbot_response, double_check_json_output
from copy import deepcopy
from dotenv import load_dotenv

class OrderTakingAgent:
    def __init__(self, recommendation_agent):
        self.client = boto3.client(
            service_name='bedrock-runtime',
            region_name='us-east-1'
        )

        self.model_id = "meta.llama3-1-8b-instruct-v1:0"
        self.model_inference_profile = 'arn:aws:bedrock:us-east-1:823413233438:inference-profile/us.meta.llama3-1-8b-instruct-v1:0'

        self.recommendation_agent = recommendation_agent

    def get_response(self, messages):
        messages = deepcopy(messages)

        system_prompt = """
            You are an Order taking agent for a coffee shop called "Merry's way".

            STRICT OUTPUT RULES:
            - You MUST reply **only in valid JSON**.
            - Any other output will crash the system.
            - NEVER include conversational text outside the JSON object.
            - If you need to ask questions, do it inside the "response" field.

            Format (Follow exactly):

            {
                "chain of thought": Short reasoning as a string
                "step number": <number>
                "order": 
                    [{
                        "item": "item name", 
                        "quantity": <number>, 
                        "price": "<item total price>" 
                    }]
                "response": "Ask about additional items or finalize the bill."
            }

            You're task is as follows:

            1. Take the User's Order
                IMPORTANT:
                *STRICTLY catch the order item (even if small spelling mistake is present)
                *STRICTLY catch the order quantity
                *You MUST not make mistake in catching the items' names and quantities

            2. Validate that all their items are in the menu. Here is the menu for this coffee shop.

                Cappuccino - $4.50
                Jumbo Savory Scone - $3.25
                Latte - $4.75
                Chocolate Chip Biscotti - $2.50
                Espresso shot - $2.00
                Hazelnut Biscotti - $2.75
                Chocolate Croissant - $3.75
                Dark chocolate (Drinking Chocolate) - $5.00
                Cranberry Scone - $3.50
                Croissant - $3.25
                Almond Croissant - $4.00
                Ginger Biscotti - $2.50
                Oatmeal Scone - $3.25
                Ginger Scone - $3.50
                Chocolate syrup - $1.50
                Hazelnut syrup - $1.50
                Carmel syrup - $1.50
                Sugar Free Vanilla syrup - $1.50
                Dark chocolate (Packaged Chocolate) - $3.00

            3. if an item is not in the menu let the user know (and repeat back the remaining valid order if any)
            4. IMPORTANT: Ask them if they need anything else. 
            5. If they do: repeat starting from step 3
            6. If they don't want anything else: 
                Using the "order" object that is in the output, 
                *Make sure to hit all three points
                1. List down all ordered items and their prices
                2. SUPER CRITICAL: Calculate the total price without any mistake
                3. Thank the user for the order and close the conversation with no more questions

            The user message will contain a section called memory. This section will contain the following:
            "order"
            "step number"

            please utilize this information to determine the next step in the process.

            IMPORTANT: 
            - DO NOT tell the user to go to the cash counter or ask how to pay.
            - If the user adds a new item, APPEND it to the existing "order" array.
            - If the user says "done", "nothing", "no", "that's all" etc., finalize the order and include the total.

            CRITICAL: 
            - No comments
            - No trailing commas 
            - No extra explanations
            - ONLY output valid JSON
            - The system parses your output with json.loads(). If you output anything else, it will crash.

        """

        last_order_taking_status = ""
        asked_recommendation_before = False

        for message_index in range(len(messages)-1, 0, -1):
            message = messages[message_index]
            
            agent_name = message.get("memory", {}).get("agent", "")
            print('agent name: ', agent_name)
            if message.get("role") == "assistant" and agent_name == "order_taking_agent":
                step_number = message['memory']['step number']
                order = message['memory']['order']
                asked_recommendation_before = message['memory']['asked_recommendation_before']

                print('step number: ', step_number)
                print('order: ', order)
                print('asked recommendation before: ', asked_recommendation_before)

                last_order_taking_status = f"""
                step number: {step_number}
                order: {order}
                """

                break

        input_messages = [{"role": "system", "content": system_prompt}]

        # Add last memory if exists
        if last_order_taking_status:
            input_messages.append({
                "role": "system",
                "content": f"Previous state:\n{last_order_taking_status}"
            })

        # Add latest user message
        input_messages.append(messages[-1])

        print('input_messages (order taking): ', input_messages)

        chatbot_response = get_chatbot_response(self.client, self.model_inference_profile, input_messages)
        print('chatbot_response (before double check): ', chatbot_response)
        
        chatbot_response = double_check_json_output(self.client, self.model_inference_profile, chatbot_response)
        print('chatbot_response (after double check): ', chatbot_response)

        output = self.postprocess(chatbot_response, messages, asked_recommendation_before)
        print('processed output JSON (order taking): ', output)

        return output
    
    def postprocess(self, output, messages, asked_recommendation_before):
        print('output (chatbot_response fed to postprocess from get_response): ', output)

        output_json = self.safe_json_load(output)
        print('output_json (in postprocess): ', output_json)

        output_json = self.safe_json_load(output)

        # Final fallback
        if not output_json:
            print("Invalid JSON received. Skipping response.")
            return {
                "role": "assistant",
                "content": "Sorry, I couldn't process that order. Could you please repeat it?",
                "memory": {
                    "agent": "order_taking_agent",
                    "step number": 1,
                    "asked_recommendation_before": False,
                    "order": []
                }
            }

        # Parse order
        if isinstance(output_json.get("order"), str):
            try:
                output_json["order"] = json.loads(output_json["order"])
            except json.JSONDecodeError:
                output_json["order"] = []


        # response = output['response']
        response = output_json.get("response", "").strip()
        order_list = output_json.get("order", [])

        print("In postprocess:")
        print('response: ', response)
        print('order list: ', order_list)

        if not asked_recommendation_before and order_list:
            rec_output = self.recommendation_agent.get_recommendations_from_order(messages, order_list)
            print('rec_output: ', rec_output)

            if isinstance(rec_output, dict) and "content" in rec_output:
                rec_text = rec_output["content"].strip()
                print('rec_text: ', rec_text)

                # Simple sanity check to avoid "apocalypse" repeats
                if rec_text and len(rec_text.split()) > 3 and rec_text.lower() != response.lower():
                    response += "\n\n" + rec_text
                    asked_recommendation_before = True

        return {
            "role": "assistant",
            "content": response,
            "memory": {
                "agent": "order_taking_agent",
                "step number": output_json.get("step number", 1),
                "asked_recommendation_before": asked_recommendation_before,
                "order": order_list
            }
        }
    
    def safe_json_load(self, output: str):
        """Extract the first valid JSON object from a string."""

        print("output (fed to safe_json_load from postprocess):", output)

        json_obj = None
        brace_count = 0
        start_idx = None
        for i, ch in enumerate(output):
            if ch == '{':
                if brace_count == 0:
                    start_idx = i
                brace_count += 1
            elif ch == '}':
                brace_count -= 1
                if brace_count == 0 and start_idx is not None:
                    try:
                        json_obj = json.loads(output[start_idx:i+1])
                        print("json_obj (in safe_json_load):", json_obj)
                        return json_obj
                    except json.JSONDecodeError:
                        continue
        # return None

        # Final fallback: ask model to repair JSON
        repaired = get_chatbot_response(
            self.client,
            self.model_inference_profile,
            [
                {
                    "role": "system",
                    "content": "Return ONLY valid JSON. Nothing else."
                },
                {"role": "user", "content": output}
            ]
        )
        
        try:
            return json.loads(repaired)
        except json.JSONDecodeError:
            print("safe_json_load: Model failed to repair JSON")
            return None


----------------------------------
----------------------------------

import boto3
import pandas as pd
import json
import re
from copy import deepcopy   # deepcopy copies by value and not by reference
import os
from .utils import get_chatbot_response, double_check_json_output
import dotenv

dotenv.load_dotenv()

class RecommendationAgent:
    def __init__(self, apriori_recommendation_path, popularity_recomendation_path):
        self.client = boto3.client(
            service_name='bedrock-runtime',
            region_name='us-east-1'
        )

        self.model_id = "meta.llama3-1-8b-instruct-v1:0"
        self.model_inference_profile = 'arn:aws:bedrock:us-east-1:823413233438:inference-profile/us.meta.llama3-1-8b-instruct-v1:0'

        # loading JSON object of the apriori algorithm
        with open(apriori_recommendation_path, 'r') as json_file:
            self.apriori_recommendations = json.load(json_file)

        # print('apriori recommendations path:', apriori_recommendation_path)
        # print('apriori recommendations from data:', self.apriori_recommendations)

        self.popularity_recommendations = pd.read_csv(popularity_recomendation_path)

        # print('popularity recommendations path:', popularity_recomendation_path)
        # print('popularity recommendations from data:', self.popularity_recommendations)

        self.products = self.popularity_recommendations['product'].tolist()
        self.product_categories = list(set(self.popularity_recommendations['product_category'].tolist()))

        # print('products:', self.products)
        # print('product categories:', self.product_categories)

    def get_apriori_recommendations(self, products, top_k=5):
        recommendation_list = []

        for product in products:
            if product in self.apriori_recommendations:
                # recommendation_list.extend(self.apriori_recommendations[product][:top_k])
                print('ordered product one:', product)

                recommendation_list += self.apriori_recommendations[product]
                print('apriori recommendations list:', self.apriori_recommendations[product])
                print('recommendation list:', recommendation_list)

        # Sort recommendation list based on "confidence" in descending order
        recommendation_list = sorted(recommendation_list, key=lambda x: x['confidence'], reverse=True)
        print('sorted recommendation list:', recommendation_list)

        recommendations = []
        recommendations_per_category = {}

        for recommendation in recommendation_list:
            if recommendation in recommendations:
                continue

            # Limit 2 recommendations per category
            product_category = recommendation['product_category']
            if product_category not in recommendations_per_category:
                recommendations_per_category[product_category] = 0

            if recommendations_per_category[product_category] >= 2:
                continue
            
            recommendations_per_category[product_category] += 1

            # Add the recommendation to the list
            recommendations.append(recommendation['product'])
            
            if len(recommendations) >= top_k:
                break

        return recommendations

    def get_popular_recommendations(self, product_categories=None, top_k=5):
        recommendation_df = self.popularity_recommendations

        print('product_categories:', product_categories)
        print('type(product_categories):', type(product_categories))

        if type(product_categories) == str:
            product_categories = [product_categories]

        if product_categories is not None:
            recommendation_df = self.popularity_recommendations[self.popularity_recommendations['product_category'].isin(product_categories)]

        print('recommendation_df:', recommendation_df)

        # sort by number of transactions (most popular at the top)
        recommendation_df = recommendation_df.sort_values('number_of_transactions', ascending=False)
        print('sorted recommendation_df:', recommendation_df)

        if recommendation_df.shape[0] == 0:
            return []

        recommendation = recommendation_df['product'].tolist()[:top_k]

        return recommendation
    
    def recommendation_classification(self, message):

        system_prompt = """ 
            You are a JSON-only API. Always output a single valid JSON object.
            Your ONLY TASK: Determine the type of recommendation based on user's message. 

            CRITICAL: Check user message very carefully to find if it mentions any ONE or MULTIPLE of the following categories:
            Coffees, Bakery (includes scones, croissants and biscotti), Flavours (includes syrups), Chocolates

            We have 3 types of recommendations:
            
            1. Popular: If the user does NOT mention any category, choose 'popular'.
            2. Popular by Category: If the user mentions a category (or related to a category), choose 'popular by category'.
            3. Apriori: If user already has an order, choose 'apriori'.

            Rules for output:
            - You MUST respond in **valid JSON only**.
            - No extra text, no explanations outside the JSON.
            - The JSON must always include all three keys: "chain_of_thought", "recommendation_type", and "parameters".
            - DO NOT add any quotes to the JSON.

            STRICTLY follow the JSON format:
            {
                "chain_of_thought": "Brief reasoning for your choice.",
                "recommendation_type": "apriori" | "popular" | "popular by category",
                "parameters": []  
                    // for 'popular': leave empty, for 'popular by category': specified categories [MUST be from: Bakery, Coffee, Flavours, Chocolate], for 'apriori': items
            }
            
            Here is the list of items in the coffee shop:
            """+ ",".join(self.products) + """
            Here is the list of Categories we have in the coffee shop:
            """ + ",".join(self.product_categories) + """

        """

        input_messages = [{"role": "system", "content": system_prompt}] + message
        # print('input messages (rec classification):', input_messages)

        chatbot_response = get_chatbot_response(self.client,self.model_inference_profile,input_messages)
        print('chatbot response (rec classification):', chatbot_response)

        # chatbot_response = double_check_json_output(self.client,self.model_inference_profile,chatbot_response)
        # print('chatbot response after double check (rec classification):', chatbot_response)

        output = self.postprocess_classfication(chatbot_response)
        print('final output (classification):', output)

        return output
    
    def postprocess_classfication(self, input):

        # output = json.loads(output)
        # try:
        #     output = json.loads(output)
        # except json.JSONDecodeError:
        #     print("Invalid JSON from model:", output)
        #     return {
        #         "recommendation_type": "popular",   # fallback   
        #         "parameters": []
        #     }

        if not input or not input.strip():
            raise ValueError("Chatbot output is empty")

        output = None
        brace_count = 0
        start_idx = None
        for i, ch in enumerate(input):
            if ch == '{':
                if brace_count == 0:
                    start_idx = i
                brace_count += 1
            elif ch == '}':
                brace_count -= 1
                if brace_count == 0 and start_idx is not None:
                    try:
                        output = json.loads(input[start_idx:i+1])
                    except json.JSONDecodeError:
                            print("Invalid JSON from model:", output)
                            return {
                                "recommendation_type": "popular",   
                                "parameters": []
                            }

        print('output:', output)
        recommendation_type = output.get('recommendation_type')
        parameters = output.get('parameters', [])
        chain_of_thought = output.get('chain_of_thought', None)

        if recommendation_type not in ["apriori", "popular", "popular by category"]:
            print("Unexpected or missing recommendation_type:", output)
            return {
                "chain_of_thought": chain_of_thought,
                "recommendation_type": "popular",   # fallback
                "parameters": parameters
            }

        return {
            "chain_of_thought": chain_of_thought,
            "recommendation_type": recommendation_type,
            "parameters": parameters
        }
    
    def get_recommendations_from_order(self, messages, order): 
        messages = deepcopy(messages)

        products = []
        for item in order:
            products.append(item.get('product') or item.get('item'))

        recommendations = self.get_apriori_recommendations(products)
        print('recommendations (from order):', recommendations)

        recommendations_str = ", ".join(recommendations)
        print('recommendations_str (from order):', recommendations_str)

        system_prompt = f"""
        You are a helpful AI assistant for a coffee shop application.
        your task is to recommend items to the user based on their already placed order. 
        Put it in an unordered list with very small descriptions. 
        Wrap with brief (1-2 sentences) and suitable words.
        """

        prompt = f"""
        {messages[-1]['content']}

        Please recommend these items exactly: {recommendations_str}

        IMPORTANT: 
        - Keep the response in an unordered list with a small description for each item
        - Keep the look clean and simple
        - Keep the response short but elegant
        - DO NOT use irrelevant words like "endlist" or such

        """

        messages[-1]['content'] = prompt
        input_messages = [{"role": "system", "content": system_prompt}] + messages[-3:]

        chatbot_response = get_chatbot_response(self.client,self.model_inference_profile,input_messages)
        
        output = self.postprocess(chatbot_response)

        return output
    
    def get_response(self, messages):
        messages = deepcopy(messages)

        print('Calling Recommendation Classifier to understand user intent...')
        recommendation_classification = self.recommendation_classification(messages)
        recommendation_type = recommendation_classification['recommendation_type']
        # parameters = recommendation_classification['parameters']

        print('recommendation_classification:', recommendation_classification)
        print('recommendation_type:', recommendation_type)
        print('parameters:', recommendation_classification['parameters'])

        recommendations = []

        if recommendation_type == "apriori":
            recommendations = self.get_apriori_recommendations(recommendation_classification['parameters'])
        elif recommendation_type == "popular":
            recommendations = self.get_popular_recommendations()
        elif recommendation_type == "popular by category":
            recommendations = self.get_popular_recommendations(product_categories= recommendation_classification['parameters'])
        
        if recommendations == []:
            return {"role": "assistant", "content": "I'm sorry, I can't help with that recommendation. Can I help you with something else?"}
        
        print('recommendations (get_response):', recommendations)

        # Respond to user
        recommendation_str = ", ".join(recommendations)
        print('recommendation_str (get_response):', recommendation_str)

        system_prompt = f"""
        You are a helpful AI assistant for a coffee shop.
        your task is to recommend items to the user like a coffee shop waiter. 
        Put recommendations in an unordered list.

        IMPORTANT: DO NOT use irrelevant texts like "inquiries" or such
        """

        prompt = f"""
        {messages[-1]['content']}

        Please recommend these items exactly: {recommendation_str}        
        """

        messages[-1]['content'] = prompt
        input_messages = [{"role": "system", "content": system_prompt}] + messages[-3:]

        print('input_messages (recommendation get_response):', input_messages)

        chatbot_response = get_chatbot_response(self.client,self.model_inference_profile,input_messages)
        print('chatbot_response (recommendation):', chatbot_response)

        output = self.postprocess(chatbot_response)
        print('post-processed output (recommendation):', output)

        # return chatbot_response
        return output
    
    def postprocess(self, output):
        output = { 
            "role": "assistant", 
            "content": output, 
            "memory": 
                {"agent": "recommendation_agent"} 
            } 
        
        return output

        # try:
        #     data = json.loads(output)
        #     return {
        #         "role": "assistant",
        #         "content": data,  # structured, clean
        #         "memory": {"agent": "recommendation_agent"}
        #     }
        # except json.JSONDecodeError:
        #     return {
        #         "role": "assistant",
        #         "content": {"recommendations": []},
        #         "memory": {"agent": "recommendation_agent"}
        #     }